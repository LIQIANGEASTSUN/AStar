https://blog.csdn.net/GJQI12/article/details/108345526?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-108345526-blog-118766080.235^v43^pc_blog_bottom_relevance_base4&spm=1001.2101.3001.4242.2&utm_relevant_index=4




做好了地图的预处理之后，我们就可以使用JPS+算法了。
大致思路与JPS算法相同，不过这次有了预处理的数据，我们可以更快的进行直线搜索和斜向搜索。

在某个搜索方向上有：
1.对于正数距离 n（意味着距离跳点 n 格），我们可以直接将n步远的节点作为跳点添加进openlist
2.对于0距离（意味着一步都不可移动），我们无需在该方向搜索；
3.对于负数距离 -n（意味着距离边界或障碍 n 格），我们直接将n步远的节点进行一次跳点判断（有可能满足跳点的第三条件，不过得益于预处理的数据，这步也可以很快完成）。



JPS+ 寻路算法中查找目标点的过程：
预处理阶段（与查找目标点的关系）：

预处理时并不直接定位目标点，而是对地图进行分析以找出所有可能的“跳点”。
这一步骤间接支持后续更快地找到目标点，因为它减少了搜索空间，使得算法在实际运行时能快速跳过大量不必要的节点。
搜索过程中的目标查找：

在搜索阶段，JPS+算法从起始点开始，并遵循跳点规则推进搜索。
当检查到一个节点时，会利用已存储的跳点信息直接跳转到下一个有意义的节点，而非遍历所有邻居。
如果某个跳点能够直接或间接地到达目标区域（例如通过goal-bounding技术），则算法会沿着这条路径继续探索直至找到确切的目标点。
goal-bounding应用（JPS+可能采用的一种优化策略）：

一种可能的增强策略是在预处理阶段确定目标区域的一个边界框（bounding box）。
在搜索过程中，当算法检测到当前节点距离目标区域的边界框足够近或者处于同一连通区域内时，它会更加精细地检查周围格子以确认是否已经到达目标点，或者是否有可以直接到达目标点的跳点。
终止条件：

当搜索算法发现一个节点与目标点相同或者可以无阻碍地到达目标点时，搜索结束。
算法随后可以通过回溯parent节点构建出从起始点到目标点的实际路径。
总之，在JPS+寻路算法中，查找目标点是通过减少搜索空间并优先考虑关键跳点来加速实现的，而并非像传统A*那样逐一检查每个相邻节点。一旦达到目标区域的有效范围，算法就会精确锁定目标点，并停止进一步的搜索。